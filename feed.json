{
    "version": "https://jsonfeed.org/version/1",
    "title": "DreamStaro",
    "subtitle": "昨夜星辰昨夜风,画楼西畔桂堂东",
    "icon": "https://seachen.cn/images/favicon.ico",
    "description": "路漫漫其修远兮，吾将上下而求索",
    "home_page_url": "https://seachen.cn",
    "items": [
        {
            "id": "https://seachen.cn/Program/c-%E6%B3%9B%E5%9E%8B%E5%92%8Cjava%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/",
            "url": "https://seachen.cn/Program/c-%E6%B3%9B%E5%9E%8B%E5%92%8Cjava%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/",
            "title": "c++泛型(模板)和java泛型的实现",
            "date_published": "2021-11-14T03:06:24.000Z",
            "content_html": "<p>面试被问到 c++ 的泛型和 java 的泛型有什么区别，回答得不是很好，来总结一下.</p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"1泛型实现\"><a class=\"anchor\" href=\"#1泛型实现\">#</a> 1. 泛型实现</h2>\n<h3 id=\"ic\"><a class=\"anchor\" href=\"#ic\">#</a> (i).c++</h3>\n<p>c++ 的泛型实现机制很简单，就是在实际编译时，类似于宏一样，把实际的类型代入模板，并针对不同的类型生成不同的代码，所以编译后代码体积会变大，但执行时就不需要额外的判断了，运行时效率会较高.</p>\n<p>所以 c++ 的泛型可以说是以空间换时间.</p>\n<h3 id=\"iijava\"><a class=\"anchor\" href=\"#iijava\">#</a> (ii).java</h3>\n<p>java 的泛型则比较复杂，java 在编译时，它会去执行类型检查和类型推断，然后生成普通的不带泛型的字节码，这种字节码可以被一般的 Java 虚拟机接收并执行，这种技术被称为擦除 (erasure).</p>\n<p>java 编译后不同类型的模板类编译出的是同一份代码。然后在使用时编译器会帮助进行类型转换.</p>\n<p>例如:</p>\n<p>原代码为:</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Pair</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> pair <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Pair</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    pair<span class=\"token punctuation\">.</span><span class=\"token function\">setFirst</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"QMI\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    pair<span class=\"token punctuation\">.</span><span class=\"token function\">setSecond</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Kang\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">String</span> first <span class=\"token operator\">=</span> pair<span class=\"token punctuation\">.</span><span class=\"token function\">getFirst</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token class-name\">String</span> second <span class=\"token operator\">=</span> pair<span class=\"token punctuation\">.</span><span class=\"token function\">getSecond</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>反编译后为:</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Pair</span> pair <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Pair</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    pair<span class=\"token punctuation\">.</span><span class=\"token function\">setFirst</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"QMI\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    pair<span class=\"token punctuation\">.</span><span class=\"token function\">setSecond</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Kang\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token class-name\">String</span> first <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span>pair<span class=\"token punctuation\">.</span><span class=\"token function\">getFirst</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token class-name\">String</span> second <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span>pair<span class=\"token punctuation\">.</span><span class=\"token function\">getSecond</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>所以 java 泛型的实现是在运行时去进行判断和类型转换的，这样会对运行时的效率有一定影响，但编译出来的泛型类的代码只需要一份.</p>\n<h2 id=\"2总结\"><a class=\"anchor\" href=\"#2总结\">#</a> 2. 总结</h2>\n<p>c<ins> 是以泛型类为模板创建出各种不同的实例，而 java 只是在类上填入 Object, 运行时进行类型转换。所以 c</ins> 的泛型是真泛型，java 的泛型是伪泛型.</p>\n",
            "tags": [
                "C++",
                "C++",
                "Java",
                "泛型"
            ]
        },
        {
            "id": "https://seachen.cn/Linux-Windows/Kali-Linux/%E5%B0%81%E8%A3%85%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84Kali-Linux-ISO/",
            "url": "https://seachen.cn/Linux-Windows/Kali-Linux/%E5%B0%81%E8%A3%85%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84Kali-Linux-ISO/",
            "title": "封装定制自己的Kali-Linux ISO",
            "date_published": "2021-09-22T13:36:17.000Z",
            "content_html": "<p>最近有个同行的人跟我提下怎么操作封装镜像，故此我总结了下如下文章</p>\n<h2 id=\"封装定制自己的-kali-linux-iso\"><a class=\"anchor\" href=\"#封装定制自己的-kali-linux-iso\">#</a> 封装定制自己的 Kali-Linux ISO</h2>\n<p><img data-src=\"https://img-blog.csdnimg.cn/img_convert/1651b82e79005f1663253d3c10f6f201.png\" alt=\"myblog\" /></p>\n<h3 id=\"kali-linux-iso-简介\"><a class=\"anchor\" href=\"#kali-linux-iso-简介\">#</a> Kali Linux ISO 简介</h3>\n<hr />\n<blockquote>\n<p>构建自定义的 Kali ISO 既简单，有趣又有意义。您几乎可以使用 Debian 动态构建脚本来配置 Kali ISO 构建的任何方面。<br />\n这些脚本允许开发人员通过提供一个框架来轻松构建实时系统映像，该框架使用配置集来自动化和自定义构建映像的所有方面。<br />\nKali Linux 开发团队已采用了这些脚本，并且已使用它们来制作正式的 Kali ISO 版本。</p>\n</blockquote>\n<h3 id=\"您应该在哪里建立-iso\"><a class=\"anchor\" href=\"#您应该在哪里建立-iso\">#</a> 您应该在哪里建立 ISO？</h3>\n<hr />\n<blockquote>\n<p>最理想的是在预装 Kali 的环境里定制你的 Kali ISO. 如果不是这样，请务必使用最新版本的 live-build 脚本。</p>\n</blockquote>\n<h3 id=\"一-准备就绪-设置实时构建系统\"><a class=\"anchor\" href=\"#一-准备就绪-设置实时构建系统\">#</a> 一、准备就绪 - 设置实时构建系统</h3>\n<hr />\n<ul>\n<li>我们首先需要通过使用以下命令安装和设置实时构建及其要求来准备 Kali ISO 构建环境：</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> -y <span class=\"token function\">curl</span> <span class=\"token function\">git</span> live-build cdebootstrap</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">git</span> clone https://gitlab.com/kalilinux/build-scripts/live-build-config.git</pre></td></tr></table></figure><ul>\n<li>github kali_live 镜像包装地址<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RDSEhWL2thbGktbGl2ZS1idWlsZC1jb25maWc=\"> github 地址入口</span></li>\n<li>现在，您只需输入 <code>live-build-config</code>  目录并运行我们的 <span class=\"exturl\" data-url=\"aHR0cDovL2J1aWxkLnNo\">build.sh</span> 包装器脚本，即可构建更新的 Kali ISO ，如下所示</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token builtin class-name\">cd</span> live-build-config/</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">></span> ./build.sh --verbose</pre></td></tr></table></figure><ul>\n<li>该 <span class=\"exturl\" data-url=\"aHR0cDovL2J1aWxkLnNo\">build.sh</span> 脚本将需要一段时间才能完成，因为它会下载创建 ISO 所需的所有必需软件包，取决于你的网络快慢。</li>\n</ul>\n<h3 id=\"二-配置-kali-iso-构建可选\"><a class=\"anchor\" href=\"#二-配置-kali-iso-构建可选\">#</a> 二、配置 Kali ISO 构建（可选）</h3>\n<hr />\n<h4 id=\"构建说明\"><a class=\"anchor\" href=\"#构建说明\">#</a> 构建说明</h4>\n<blockquote>\n<p>如果您想自定义您的 Kali Linux ISO，本节将解释一些细节。通过 kali-config 目录，Kali Linux live build 支持各种自定义选项，这些选项在 Debian live build 4.x 页面上有详细记录。但是，对于不耐烦的人，这里是一些重点。</p>\n</blockquote>\n<h4 id=\"使用不同的桌面环境构建-kali\"><a class=\"anchor\" href=\"#使用不同的桌面环境构建-kali\">#</a> 使用不同的桌面环境构建 Kali</h4>\n<blockquote>\n<p>从 Kali 2.0 开始，我们现在支持各种桌面环境的内置配置，包括 <code>KDE，Gnome，E17，I3WM，LXDE，MATE和XFCE</code> 。要构建其中的任何一个，您将使用类似于以下内容的语法：</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#These are the different Desktop Environment build options:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> <span class=\"token operator\">></span> ./build.sh --variant <span class=\"token punctuation\">&#123;</span>gnome,kde,xfce,mate,e17,lxde,i3wm<span class=\"token punctuation\">&#125;</span> --verbose</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> <span class=\"token comment\">#To build a KDE ISO:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre> <span class=\"token operator\">></span> ./build.sh --variant kde --verbose</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> <span class=\"token comment\">#To build a MATE ISO:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre> <span class=\"token operator\">></span> ./build.sh --variant mate --verbose</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> <span class=\"token comment\">#...and so on.</span></pre></td></tr></table></figure><h4 id=\"控制构建中包含的软件包\"><a class=\"anchor\" href=\"#控制构建中包含的软件包\">#</a> 控制构建中包含的软件包</h4>\n<blockquote>\n<ul>\n<li>您的构建中包含的软件包列表将出现在相应的 <code>kali- $ variant</code>  目录中。</li>\n<li>例如，如果要构建默认的 Xfce ISO，则应使用以下软件包列表文件 <code>-kali-config / variant-xfce / package-lists / kali.list.chroot</code> 。</li>\n<li>默认情况下，此列表包括 <code>kali-linux-default</code>  元软件包以及其他一些软件包。可以将它们注释掉并替换为包的手动列表，以包括在 ISO 中以获得更大的定制性。</li>\n</ul>\n</blockquote>\n<h4 id=\"说明\"><a class=\"anchor\" href=\"#说明\">#</a> 说明</h4>\n<blockquote>\n<ul>\n<li><code>config</code>  目录里包含了定制 ISO 的各种重要的自定义选项，这些选项在 Debian 的 live build 3.x 页面有文档说明。然而如果你没有耐心，请特别注意以下的配置文件:</li>\n<li><code>config/package-lists/kali.list.chroot</code>  包含要安装在 Kali ISO 里的软件包的列表。你可以指定移除已经安装的软件包。也可以切换你的 Kali ISO 的桌面环境 (KDE,Gnome,XFCE,LXDE 等).</li>\n<li><code>hooks/ – hooks</code>  目录允许我们在不同阶段调用脚本封装定制 Kali Live ISO. 更多关于 hooks 的信息，参考 live build 手册。举个例子，Kali 是这样添加取证模式的引导菜单的:</li>\n</ul>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">cat</span> config/hooks/forensic-menu.binary</pre></td></tr></table></figure><figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token shebang important\">#!/bin/sh</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">cat</span> <span class=\"token operator\">>></span>binary/isolinux/live.cfg <span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">END</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>label live-forensic</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    menu label ^Live (forensic mode)</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    linux /live/vmlinuz</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    initrd /live/initrd.img</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    append boot=live noconfig username=root hostname=kali noswap noautomount</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>END</span></pre></td></tr></table></figure><h3 id=\"三-封装-iso\"><a class=\"anchor\" href=\"#三-封装-iso\">#</a> 三、封装 ISO</h3>\n<hr />\n<blockquote>\n<p>在封装 ISO 之前，可以指定需要的架构，选择 amd64 或者 i386. 还要注意 <code>lb build</code>  需要 root 权限。如果你不指定架构，live build 将根据你现在使用的架构来封装 ISO.</p>\n</blockquote>\n<ul>\n<li>如果你想在在 32 位系统封装 64 位的 ISO, 务必打开多架构支持:</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> dpkg --add-architecture amd64</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">apt-get</span> update</pre></td></tr></table></figure><ul>\n<li>配置 live-build 封装 64 位或者 32 位 ISO:</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> lb config --architecture amd64 <span class=\"token comment\"># for 64 bit</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># ...or...</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> lb config --architecture i386  <span class=\"token comment\"># for 32 bit</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># ...finshed...</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> lb build</pre></td></tr></table></figure><ul>\n<li>最后一个命令需要一些时间，因为它下载所有需要的软件包然后封装 ISO. 可以先去喝杯咖啡.</li>\n</ul>\n<h3 id=\"四-为今后封装-iso-提速\"><a class=\"anchor\" href=\"#四-为今后封装-iso-提速\">#</a> 四、为今后封装 ISO 提速</h3>\n<hr />\n<blockquote>\n<p>如果你打算经常定制 ISO, 你可以把 kali 的软件包缓存在本地便于今后的封装。最简单的就是安装 apt-cacher-ng, 然后在每次打包时配置 http_proxy 环境变量.</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> apt-cacher-ng</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">></span> /etc/init.d/apt-cacher-ng start</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">http_proxy</span><span class=\"token operator\">=</span>http://localhost:3142/<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span> <span class=\"token comment\"># setup and configure your live build</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">></span> lb config --apt-http-proxy http://127.0.0.1:3142/</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> lb build</pre></td></tr></table></figure><h3 id=\"五-为较早的-i386-架构封装-iso附加\"><a class=\"anchor\" href=\"#五-为较早的-i386-架构封装-iso附加\">#</a> 五、为较早的 i386 架构封装 ISO（附加）</h3>\n<hr />\n<h4 id=\"i386-架构封装-iso\"><a class=\"anchor\" href=\"#i386-架构封装-iso\">#</a> i386 架构封装 ISO</h4>\n<blockquote>\n<p>Kali Linux i386 ISO 已启用 PAE。如果您需要禁用 PAE 的较旧硬件的默认内核，则需要重建 Kali Linux ISO。</p>\n</blockquote>\n<ul>\n<li>重建过程与上述过程基本相同，不同之处在于，需要按如下所示在 <code>auto / config</code>  中将 <code>686-pae参数更改为586</code> 。首先，安装先决条件。</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> -y <span class=\"token function\">git</span> live-build cdebootstrap <span class=\"token function\">debootstrap</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">git</span> clone https://gitlab.com/kalilinux/build-scripts/live-build-config.git</pre></td></tr></table></figure><ul>\n<li>接下来，针对适当的架构在 <code>auto / config</code>  中进行更改：</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token builtin class-name\">cd</span> live-build-config/</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">sed</span> -i <span class=\"token string\">'s/686-pae/686/g'</span> auto/config</pre></td></tr></table></figure><ul>\n<li>最后，运行您的构建。</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> ./build.sh --arch i386 --verbose</pre></td></tr></table></figure><h4 id=\"在基于非-kali-debian-的系统上构建-kali\"><a class=\"anchor\" href=\"#在基于非-kali-debian-的系统上构建-kali\">#</a> 在基于非 KALI DEBIAN 的系统上构建 KALI</h4>\n<blockquote>\n<p>您可以在 Kali 以外的基于 Debian 的系统上轻松运行实时构建。以下说明已经过测试，可以与 Debian 和 Ubuntu 一起使用。</p>\n</blockquote>\n<ul>\n<li>首先，我们通过确保系统已完全更新来准备系统，然后继续下载 Kali 存档密钥链和实时构建软件包。</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> upgrade</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token builtin class-name\">cd</span> /root/</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">wget</span> http://http.kali.org/pool/main/k/kali-archive-keyring/kali-archive-keyring_2018.2_all.deb</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">wget</span> https://archive.kali.org/kali/pool/main/l/live-build/live-build_20190311_all.deb</pre></td></tr></table></figure><ul>\n<li>完成后，我们将安装一些其他依赖项和以前下载的文件。</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> -y <span class=\"token function\">git</span> live-build cdebootstrap <span class=\"token function\">debootstrap</span> <span class=\"token function\">curl</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">sudo</span> dpkg -i kali-archive-keyring_2018.2_all.deb</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">sudo</span> dpkg -i live-build_20190311_all.deb</pre></td></tr></table></figure><ul>\n<li>准备好所有环境后，我们通过设置构建脚本并检查出构建配置来开始实时构建过程。</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token builtin class-name\">cd</span> /usr/share/debootstrap/scripts/</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"default_mirror http://http.kali.org/kali\"</span><span class=\"token punctuation\">;</span> <span class=\"token function\">sed</span> -e <span class=\"token string\">\"s/debian-archive-keyring.gpg/kali-archive-keyring.gpg/g\"</span> sid <span class=\"token operator\">></span> /tmp/kali</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">sudo</span> <span class=\"token function\">mv</span> /tmp/kali <span class=\"token builtin class-name\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">sudo</span> <span class=\"token function\">ln</span> -s kali kali-rolling</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token builtin class-name\">cd</span> ~</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">git</span> clone https://gitlab.com/kalilinux/build-scripts/live-build-config.git</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token builtin class-name\">cd</span> live-build-config/</pre></td></tr></table></figure><ul>\n<li>此时，我们必须编辑 <span class=\"exturl\" data-url=\"aHR0cDovL2J1aWxkLnNo\">build.sh</span> 脚本以绕过版本检查。为此，我们注释掉下面的 <code>exit 1</code> 。</li>\n</ul>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre># Check we have a good debootstrap</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>ver_debootstrap=$(dpkg-query -f '$&#123;Version&#125;' -W debootstrap)</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>if dpkg --compare-versions \"$ver_debootstrap\" lt \"1.0.97\"; then</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>if ! echo \"$ver_debootstrap\" | grep -q kali; then</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>echo \"ERROR: You need debootstrap >= 1.0.97 (or a Kali patched debootstrap). Your current version: $ver_debootstrap\" >&amp;2</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>exit 1</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>fi</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>fi</pre></td></tr></table></figure><ul>\n<li>进行更改后，脚本应如下所示：</li>\n</ul>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre># Check we have a good debootstrap</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>ver_debootstrap=$(dpkg-query -f '$&#123;Version&#125;' -W debootstrap)</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>if dpkg --compare-versions \"$ver_debootstrap\" lt \"1.0.97\"; then</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>if ! echo \"$ver_debootstrap\" | grep -q kali; then</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>echo \"ERROR: You need debootstrap >= 1.0.97 (or a Kali patched debootstrap). Your current version: $ver_debootstrap\" >&amp;2</pre></td></tr><tr><td data-num=\"6\"></td><td><pre># exit 1</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>fi</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>fi</pre></td></tr></table></figure><ul>\n<li>此时，我们可以正常建立 ISO</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">sudo</span> ./build.sh --variant light --verbose</pre></td></tr></table></figure>",
            "tags": [
                "Linux/Windows",
                "Kali-Linux",
                "Kali",
                "Linux"
            ]
        },
        {
            "id": "https://seachen.cn/Program/%E6%B5%85%E8%B0%88%E5%AF%B9Spring-IOC%E5%92%8CDI%E7%9A%84%E7%90%86%E8%A7%A3/",
            "url": "https://seachen.cn/Program/%E6%B5%85%E8%B0%88%E5%AF%B9Spring-IOC%E5%92%8CDI%E7%9A%84%E7%90%86%E8%A7%A3/",
            "title": "浅谈对Spring IOC以及DI的理解",
            "date_published": "2021-07-21T01:06:24.000Z",
            "content_html": "<p>学习过 spring 框架的人一定都会听过 Spring 的 IoC (控制反转) 、DI (依赖注入) 这两个概念，对于初学 Spring 的人来说，总觉得 IoC 、DI 这两个概念是模糊不清的，是很难理解的，笔者入门之时就深受其苦，今天和大家分享网上的一些技术大牛们对 Spring 框架的 IOC 的理解以及个人对 Spring Ioc 的理解。</p>\n<h2 id=\"1个人对-ioc控制反转和-di依赖注入的理解\"><a class=\"anchor\" href=\"#1个人对-ioc控制反转和-di依赖注入的理解\">#</a> 1. 个人对 IOC（控制反转）和 DI（依赖注入）的理解</h2>\n<p>我们平时在开发 Java Web 程序的时候，每个对象在需要使用它的合作对象是，自己都要讲它要合作对象创建出来（比如 new 对象），这个合作对象是自己主动创建出来的。创建合作对象的主动全在自己受伤，需要时候就主动创建，这样耦合性很高。在这稍微解释一下耦合性概念：A 对象需要使用合作对象 B 来共同完成一件事，A 要使用 B，那么 A 对 B 产生了依赖，也就是 A 和 B 之间存在一种耦合关系，并且是紧密耦合一起的。</p>\n<p>但是这种高度的耦合性在使用了 ASPringle 之后就不一样了，创建合作对象 B 的工作是由 Spring 来做的，Spring 创建好 B 对象，然后存储到一个容器里面，当 A 对象需要使用 B 对象是，Spring 就从存放对象的那个容器里面去除 A 要使用的那么 B 对象，然后交给 A 对象使用，至于 Spring 试试如何创建那个对象，以及什么时候创建好对象的，A 对象不需要关心这些细节问题，A 得到 Spring 给我们的都西昂之后，两个人一起写作完成要完成的工作即可。</p>\n<blockquote>\n<p>所以控制反转 IOC（Inversion Of Control）是说创建对象的控制权进行转移，以前创建对象的主动全和创建时机是由自己把我的，而现在这种权力转移到第三方，比如转移交给了 IOC 容易，他就是专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IOC 容器，依赖关系就变了，原先的依赖关系就没了，他们都依赖 IOC 容器了，通过 IOC 容器来建立他们之间的关系。</p>\n</blockquote>\n<blockquote>\n<p>DI（依赖注入）其实就是 IOC 的一种类型，还有一种是 DL（Dependency Lookup 依赖查找）。DL 由 Martin Dowler 在 2004 年初的一篇论文中首次提出的。他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了。</p>\n</blockquote>\n<h2 id=\"2网上大神的对-ioc-的看法\"><a class=\"anchor\" href=\"#2网上大神的对-ioc-的看法\">#</a> 2. 网上大神的对 IOC 的看法</h2>\n<h3 id=\"一分享凯涛对-ioc-的精彩讲解\"><a class=\"anchor\" href=\"#一分享凯涛对-ioc-的精彩讲解\">#</a> （一）分享凯涛对 IOC 的精彩讲解</h3>\n<ol>\n<li>IOC 是什么<br />\n IOC-Inversion Of Control，即 “控制反转”，不是什么技术，而是一种设计思想。在 Java 开发中，IOC 意味着讲你设计好的都西昂交给容器控制，而不是传统在你的对象内部直接控制。如何理解好 IOC 呢？理解好 IOC 的关键是要明确 “谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</li>\n</ol>\n<blockquote>\n<p>谁控制谁，控制什么：传统 Java SE 程序设计，我们直接在对象内部通过 new 进行创建对象，是程序主动主动去创建依赖对象；而 IOC 是由专门一个容器来创建这些对象，即由 IOC 容器来控制对象的创建；谁控制谁？当然是 IOC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p>\n</blockquote>\n<blockquote>\n<p>为何事反转，哪方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制区直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接收依赖对象，所以用图例说明一下，传统程序设计如下图 1，都是主动区创建相关对象然后再组合起来：</p>\n</blockquote>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/DreamStar1996/ImageHub-CDN@1.1.3/FileImage/%E4%BC%A0%E7%BB%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg\" alt=\"传统程序设计结构示意图\" title=\"图1 传统程序设计结构示意图\" /></p>\n<blockquote>\n<p>当有了 IOC/DI 的容器后，在客户端类中不在诸佛那个区创建这些对象了，如图 2 所示</p>\n</blockquote>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/DreamStar1996/ImageHub-CDN@1.1.3/FileImage/%E6%9C%89IOC-DI%E5%AE%B9%E5%99%A8%E5%90%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg\" alt=\"有IOC/DI容器后程序结构示意图\" title=\"图2 有IOC/DI容器后程序结构示意图\" /></p>\n<ol>\n<li>\n<p>IOC 能做什么<br />\n IOC 不是一种技术，只是一种思想，一个重要的面像都西昂编程的法则，它能知道我们如何设计出松耦合，更优良的程序。传统应用程序都是有我们在类内部主动创建依赖对象，从而导致类鱼类之间高耦合，难于测试；有了 IOC 容器后，把创建和查找依赖兑现的控制权交给容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合这样也方便测试，利于功能 扶永发，更 重要的是是的程序的整个体系结构变得非常灵活。<br />\n其实 IoC 对编程带来的最大改变不是从代码上，而是从思想上，发生了 “主从换位” 的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 IoC/DI 思想中，应用程序就变成被动的了，被动的等待 IoC 容器来创建并注入它所需要的资源了。<br />\nIoC 很好的体现了面向对象设计法则之一 —— 好莱坞法则：“别找我们，我们找你”；即由 IoC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p>\n</li>\n<li>\n<p>IoC 和 DI<br />\nDI—Dependency Injection，即 “依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>\n</li>\n</ol>\n<p>理解 DI 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p>\n<p>● 谁依赖于谁：当然是应用程序依赖于 IoC 容器；<br />\n● 为什么需要依赖：应用程序需要 IoC 容器来提供对象需要的外部资源；<br />\n● 谁注入谁：很明显是 IoC 容器注入应用程序某个对象，应用程序依赖的对象；<br />\n● 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>\n<p>IoC 和 DI 由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年大师级人物 Martin Fowler 又给出了一个新的名字：“依赖注入”，相对 IoC 而言，“依赖注入” 明确描述了 “被注入对象依赖 IoC 容器配置依赖对象”。</p>\n<h3 id=\"二分享另一位大神没找到源链接对-ioc-与-di-浅显易懂的讲解\"><a class=\"anchor\" href=\"#二分享另一位大神没找到源链接对-ioc-与-di-浅显易懂的讲解\">#</a> （二）分享另一位大神（没找到源链接）对 IoC 与 DI 浅显易懂的讲解</h3>\n<ol>\n<li>IoC (控制反转)<br />\n　　首先想说说 IoC（Inversion of Control，控制反转）。这是 spring 的核心，贯穿始终。所谓 IoC，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看看找到自己喜欢的，然后打听她们的兴趣爱好、qq 号、电话号………，想办法认识她们，投其所好送其所要…… 这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己 new 一个），使用完之后还要将对象销毁，对象始终会和其他的接口或类耦合起来。</li>\n</ol>\n<p>那么 IoC 是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个要求的列表，告诉它我想找个什么样的女朋友，然后婚介就会按照我们的要求，提供一个女孩，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring 所倡导的开发方式就是如此，所有的类都会在 spring 容器中登记，告诉 spring 你是个什么东西，你需要什么东西，然后 spring 会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring 来控制，也就是说控制对象生存周期的不再是引用它的对象，而是 spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被 spring 控制，所以这叫控制反转。</p>\n<ol start=\"2\">\n<li>DI (依赖注入)<br />\n　　 IoC 的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过 DI（Dependency Injection，依赖注入）来实现的。比如对象 A 需要操作数据库，以前我们总是要在 A 中自己编写代码来获得一个 Connection 对象，有了 spring 我们就只需要告诉 spring，A 中需要一个 Connection，至于这个 Connection 怎么构造，何时构造，A 不需要知道。在系统运行时，spring 会在适当的时候制造一个 Connection，然后像打针一样，注射到 A 当中，这样就完成了对各个对象之间关系的控制。A 需要依赖 Connection 才能正常运行，而这个 Connection 是由 spring 注入到 A 中的，依赖注入的名字就这么来的。那么 DI 是如何实现的呢？ Java 1.3 之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring 就是通过反射来实现注入的。</li>\n</ol>\n<h2 id=\"3后述\"><a class=\"anchor\" href=\"#3后述\">#</a> 3. 后述</h2>\n<div class=\"note primary\">\n<p>如果想要更加深入的了解 IoC 和 DI，请参考大师级人物 Martin Fowler 的一篇经典文章《Inversion of Control Containers and the Dependency Injection pattern》</p>\n</div>\n",
            "tags": [
                "Spring",
                "Java",
                "设计思想"
            ]
        },
        {
            "id": "https://seachen.cn/Cloud-Deskop/A%E9%83%A8%E5%88%86-Azure-900%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
            "url": "https://seachen.cn/Cloud-Deskop/A%E9%83%A8%E5%88%86-Azure-900%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
            "title": "A部分 Azure-900基础知识(描述云的概念)",
            "date_published": "2021-07-06T00:36:17.000Z",
            "content_html": "<h1 id=\"a-部分-azure-900-基础知识\"><a class=\"anchor\" href=\"#a-部分-azure-900-基础知识\">#</a> A 部分 Azure-900 基础知识</h1>\n<h2 id=\"部分\"><a class=\"anchor\" href=\"#部分\">#</a> 部分</h2>\n<p>1、描述云概念<br />\n 2、描述核心 Azure 服务<br />\n 3、描述 Azure 上的核心解决方案和管理工具<br />\n 4、描述一般安全和网络安全功能<br />\n 5、描述身份、治理、隐私和合规性功能<br />\n 6、描述 Azure 成本管理和服务级别协议</p>\n<h2 id=\"考试-a\"><a class=\"anchor\" href=\"#考试-a\">#</a> 考试 A</h2>\n<h3 id=\"问题-1\"><a class=\"anchor\" href=\"#问题-1\">#</a> 问题 1</h3>\n<blockquote>\n<ol>\n<li>平台即服务（PaaS）解决方案 Azure 中的 Web 应用提供了对承载应用程序的操作系统。[x]</li>\n<li>平台即服务（PaaS）解决方案 Azure 中的 Web 应用提供了扩展紫红打开平台。 [√]</li>\n<li>平台即服务（PaaS）解决方案 Azure 中的 Web 应用提供专业的不断添加功能的开发服务定义应用程序。 [√]</li>\n</ol>\n</blockquote>\n<h4 id=\"解答\"><a class=\"anchor\" href=\"#解答\">#</a> 解答</h4>\n<div class=\"note info\">\n<ol>\n<li>否<br />\n原因：PaaS 解决方案不提供对操作系统的访问。 Azure Web Apps 服务提供供您托管 Web 应用程序的环境。 在幕后，Web 应用程序托管在运行 IIS 的虚拟机。 但是，您无法直接访问虚拟机，操作系统或 IIS。</li>\n<li>是<br />\n原因：在 Azure 中托管 Web 应用程序的 PaaS 解决方案确实提供了自动扩展平台的能力。这称为自动缩放。 在幕后，Web 应用程序托管在运行的虚拟机上信息系统。 自动缩放意味着添加更多负载平衡的虚拟机来托管 Web 应用程序。</li>\n<li>是<br />\n原因：PaaS 提供了一个框架，开发人员可以在此基础上开发或定制基于云的应用程序。 PaaS 开发工具可以减少使用预编码应用程序编写新应用程序所需的时间平台内置的组件，例如工作流、目录服务、安全功能、搜索等上。</li>\n</ol>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9henVyZS5taWNyb3NvZnQuY29tL2VuLWdiL292ZXJ2aWV3L3doYXQtaXMtcGFhcy8=\">https://azure.microsoft.com/en-gb/overview/what-is-paas/</span></p>\n</div>\n<h3 id=\"问题-2\"><a class=\"anchor\" href=\"#问题-2\">#</a> 问题 2</h3>\n<blockquote>\n<ol>\n<li>Azure 提供了不同资本之间的灵活性支出（资本支出）和运营 Exponditure（运营成本）。 [√]</li>\n<li>如果你创建了两个 Azure 虚拟机使用 B2S 大小，每个虚拟机将总是产生相同的每月成本。 [x]</li>\n<li>当 Azure 虚拟机停止时，你继续支付与虚拟机。[√]</li>\n</ol>\n</blockquote>\n<h4 id=\"解答-2\"><a class=\"anchor\" href=\"#解答-2\">#</a> 解答</h4>\n<div class=\"note info\">\n<ol>\n<li>是<br />\n原因：传统上，IT 支出被视为资本支出 (CapEx)。 今天，随着搬到云和现收现付模式，组织有能力扩展他们的预算，并且将其 IT 资本支出成本转为运营支出 (OpEx)。 这种灵活性，在会计方面，由于购买软件、云存储和其他 IT 相关的 “即服务” 模式，现在是一种选择资源。</li>\n<li>否<br />\n原因：使用相同大小的两个虚拟机可能具有不同的磁盘配置。 因此，每月成本可能不同。</li>\n<li>是<br />\n原因：当 Azure 虚拟机停止时，您无需为虚拟机付费。 但是，您仍然需要支付用于与虚拟机相关的存储成本。 最常见的存储成本是磁盘附加到虚拟机。 还有其他与虚拟机相关的存储成本例如用于诊断数据和虚拟机备份的存储。</li>\n</ol>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZXJpdHNvbHV0aW9ucy5jb20vY2FwZXgtdnMtb3BleC1jbG91ZC1jb21wdXRpbmctYmxvZy8=\">https://meritsolutions.com/capex-vs-opex-cloud-computing-blog/</span></p>\n</div>\n<h3 id=\"问题-3\"><a class=\"anchor\" href=\"#问题-3\">#</a> 问题 3</h3>\n<blockquote>\n<p>当你实现软件即服务（SaaS）时解决方案，你负责 (D)<br />\n A. 配置高可用性 [x]<br />\n B. 定义可伸缩规则 [x]<br />\n C. 安装 SaaS 解决方案 [x]<br />\n D. 配置 SaaS 解决方案 [√]</p>\n</blockquote>\n<h4 id=\"解答-3\"><a class=\"anchor\" href=\"#解答-3\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：</p>\n<ol>\n<li>当你实施软件即服务（SaaS）解决方案时，你有责任配置 SaaS 解决方案，其他一切由云提供商管理。</li>\n<li>SaaS 需要最少的管理，云提供商负责管理一切，而最终用户只是使用该软件。</li>\n<li>软件即服务 (SaaS) 允许用户通过 Internet 连接和使用基于云的应用程序。<br />\n常见示例是电子邮件、日历和办公工具（例如 Microsoft Office 365）。</li>\n<li>SaaS 提供了一个完整的软件解决方案，您可以从云中以现收现付的方式购买服务提供者。 您为您的组织租用应用程序，您的用户通过 Internet，通常使用 Web 浏览器。 所有底层基础设施、中间件、应用软件和应用数据位于服务提供商的数据中心。 服务提供商管理硬件和软件和适当的服务协议，将确保应用程序的可用性和安全性以及您的数据。</li>\n</ol>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9henVyZS5taWNyb3NvZnQuY29tL2VuLWluL292ZXJ2aWV3L3doYXQtaXMtc2Fhcy8=\">https://azure.microsoft.com/en-in/overview/what-is-saas/</span><br />\n 链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tZ2IvbGVhcm4vbW9kdWxlcy9wcmluY2lwbGVzLWNsb3VkLWNvbXB1dGluZy81LXR5cGVzLW9mLWNsb3VkLXNlcnZpY2Vz\">https://docs.microsoft.com/en-gb/learn/modules/principles-cloud-computing/5-types-of-cloud-services</span></p>\n</div>\n<h3 id=\"问题-4\"><a class=\"anchor\" href=\"#问题-4\">#</a> 问题 4</h3>\n<blockquote>\n<p>你有一个包含多个服务器的本地网络。你将所有服务器迁移到 Azure。<br />\n如果单个 Azure 数据中心长时间脱机，你需要推荐一种解决方案以确保某些服务器可用。<br />\n你应该在建议中包含哪些内容（ A ）？<br />\nA. 容错 B. 弹性 C. 可扩展性 D. 低延迟</p>\n</blockquote>\n<h4 id=\"解答-4\"><a class=\"anchor\" href=\"#解答-4\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：</p>\n<ol>\n<li>容错是系统在其某些功能发生故障时继续运行的能力组件。</li>\n<li>在这个问题中，您可以拥有跨数据中心复制的服务器。</li>\n<li>可用区扩展了您必须保持应用程序可用性和虚拟机上的数据。可用区是 Azure 区域内唯一的物理位置。每个区是由一个或多个配备独立电源、冷却和网络的数据中心组成。至确保弹性，在所有启用的区域中至少有三个独立的区域。物理区域内的可用区分离可保护应用程序和数据免受数据中心故障的影响。借助可用区，Azure 提供业界最佳的 99.99% VM 正常运行时间 SLA。通过构建您的解决方案在区域中使用复制的 VM，您可以保护您的应用程序和数据免受数据中心丢失的影响。如果一个区域受到威胁，然后复制的应用程序和数据会立即在另一个区域中可用。</li>\n</ol>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvYXp1cmUvdmlydHVhbC1tYWNoaW5lcy93aW5kb3dzL21hbmFnZS1hdmFpbGFiaWxpdHk=\">https://docs.microsoft.com/en-us/azure/virtual-machines/windows/manage-availability</span></p>\n</div>\n<h3 id=\"问题-5\"><a class=\"anchor\" href=\"#问题-5\">#</a> 问题 5</h3>\n<blockquote>\n<p>托管其基础设施的组织 (C) 不再需要数据中心。<br />\nA. 在私有云中 [x]<br />\n B. 在混合云中 [x]<br />\n C. 在公共云中 [√]<br />\n D. 在 Hype-V 主机上 [x]</p>\n</blockquote>\n<h4 id=\"解答-5\"><a class=\"anchor\" href=\"#解答-5\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：</p>\n<ol>\n<li>私有云托管在您的数据中心。 因此，如果您使用的是私有云，则无法关闭数据中心。</li>\n<li>公共云在外部托管，例如在 Microsoft Azure 中。 一个托管其的组织公共云中的基础设施可以关闭其数据中心。</li>\n<li>公共云是最常见的部署模型。 在这种情况下，您没有要管理的本地硬件或保持最新 --- 一切都在您的云提供商的硬件上运行。</li>\n<li>Microsoft Azure 是公共云提供商的一个示例。</li>\n<li>在私有云中，您在自己的数据中心创建云环境并提供自助访问为组织中的用户计算资源。 这为您的用户提供了公共云的模拟，但您仍对硬件和软件的购买和维护负全部责任您提供的服务。</li>\n</ol>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tZ2IvbGVhcm4vbW9kdWxlcy9wcmluY2lwbGVzLWNsb3VkLWNvbXB1dGluZy80LWNsb3VkLWRlcGxveW1lbnQtbW9kZWxz\">https://docs.microsoft.com/en-gb/learn/modules/principles-cloud-computing/4-cloud-deployment-models</span></p>\n</div>\n<h3 id=\"问题-6\"><a class=\"anchor\" href=\"#问题-6\">#</a> 问题 6</h3>\n<blockquote>\n<p>公有云的两个特点是什么？（DE）每个正确答案都提供了一个完整的解决方案。<br />\nA. 专用硬件 [x]<br />\n B. 不安全的链接 [x]<br />\n C. 有限的存储空间 [x]<br />\n D. 计量定价 [√]<br />\n E. 自助管理 [√]</p>\n</blockquote>\n<h4 id=\"解答-6\"><a class=\"anchor\" href=\"#解答-6\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：</p>\n<ol>\n<li>使用公共云，您可以获得即用即付的定价 —— 您只需为使用的内容付费，没有资本支出成本。</li>\n<li>使用公共云，您可以进行自助式管理。 您负责部署和虚拟机或网站等云资源的配置。 底层硬件<br />\n托管云资源由云提供商管理。</li>\n<li>不正确的答案：<br />\nA：您没有专用硬件。 底层硬件是共享的，因此您可以拥有多个使用托管在同一物理硬件上的云资源的客户。<br />\nB：与公共云的连接是安全的。<br />\nC：存储不受限制。 您可以拥有任意多的存储空间。</li>\n</ol>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tZ2IvbGVhcm4vbW9kdWxlcy9wcmluY2lwbGVzLWNsb3VkLWNvbXB1dGluZy80LWNsb3VkLWRlcGxveW1lbnQtbW9kZWxz\">https://docs.microsoft.com/en-gb/learn/modules/principles-cloud-computing/4-cloud-deployment-models</span></p>\n</div>\n<h3 id=\"问题-7\"><a class=\"anchor\" href=\"#问题-7\">#</a> 问题 7</h3>\n<blockquote>\n<p>当计划将公共网站迁移到 Azure 时，你必须计划（B）<br />\nA. 部署 VPN [x]<br />\n B. 支付每月使用费用 [√]<br />\n C. 付费将所有网站数据传输到 Azure [x]<br />\n D. 减少与网站的连接数 [x]</p>\n</blockquote>\n<h4 id=\"解答-7\"><a class=\"anchor\" href=\"#解答-7\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：<br />\n计划将公共网站迁移到 Azure 时，必须计划支付每月的使用费用。这是因为 Azure 使用即用即付模型。</p>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZXJpdHNvbHV0aW9ucy5jb20vY2FwZXgtdnMtb3BleC1jbG91ZC1jb21wdXRpbmctYmxvZy8=\">https://meritsolutions.com/capex-vs-opex-cloud-computing-blog/</span></p>\n</div>\n<h3 id=\"问题-8\"><a class=\"anchor\" href=\"#问题-8\">#</a> 问题 8</h3>\n<blockquote>\n<p>贵公司计划将其所有数据和资源迁移到 Azure。<br />\n该公司的迁移计划规定，只能在 Azure 中使用平台即服务（PaaS）解决方案。<br />\n需要部署符合公司迁移计划的 Azure 环境。解决方案：创建 Azure 应用服务和 Azure SQL 数据库<br />\n这符合目标吗？<br />\n是的 [√] <br />\n不 [x]</p>\n</blockquote>\n<h4 id=\"解答-8\"><a class=\"anchor\" href=\"#解答-8\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：<br />\nAzure 应用服务时一种 PaaS（平台即服务）服务。但是，Azure 虚拟机时一种 IaaS（基础设施即服务）服务。因此，该解决方案不符合目标。</p>\n</div>\n<h3 id=\"问题-9\"><a class=\"anchor\" href=\"#问题-9\">#</a> 问题 9</h3>\n<blockquote>\n<p>贵公司计划将其所有数据和资源迁移到 Azure。<br />\n该公司的迁移计划规定，只能在 Azure 中使用平台即服务（PaaS）解决方案。<br />\n需要部署符合公司迁移计划的 Azure 环境。解决方案：创建 Azure 应用服务和安装了 Microsoft SQL Server 的 Azure 虚拟机。<br />\n这符合目标吗？<br />\n是的 [x] <br />\n不 [√]</p>\n</blockquote>\n<h4 id=\"解答-9\"><a class=\"anchor\" href=\"#解答-9\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：<br />\nAzure 应用服务时一种 PaaS（平台即服务）服务。但是，Azure 存储账户时一种 IaaS（基础设施即服务）服务。因此，该解决方案不符合目标。</p>\n</div>\n<h3 id=\"问题-10\"><a class=\"anchor\" href=\"#问题-10\">#</a> 问题 10</h3>\n<blockquote>\n<p>贵公司计划将其所有数据和资源迁移到 Azure。<br />\n该公司的迁移计划规定，只能在 Azure 中使用平台即服务（PaaS）解决方案。<br />\n需要部署符合公司迁移计划的 Azure 环境。解决方案：创建 Azure 应用服务和 Azure 存储账户。<br />\n这符合目标吗？<br />\n是的 [x] <br />\n不 [√]</p>\n</blockquote>\n<h4 id=\"解答-10\"><a class=\"anchor\" href=\"#解答-10\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：<br />\nAzure 应用服务时一种 PaaS（平台即服务）服务。但是，Azure 存储账户时一种 IaaS（基础设施即服务）服务。因此，该解决方案不符合目标。</p>\n</div>\n<h3 id=\"问题-11\"><a class=\"anchor\" href=\"#问题-11\">#</a> 问题 11</h3>\n<blockquote>\n<p>你的公司托管了一个名为 App1 的会计应用程序。该应用程序有公司所有客户使用。<br />\nApp1 在每个月的前瞻周使用率较低。而在每个越的最后一周使用率很高。<br />\nAzure 云服务的哪些优势支持次磊使用模式的成本管理？（C）<br />\nA. 高可用性 [x]<br />\n B. 高延迟 [x]<br />\n C. 弹性 [√]<br />\n D. 负载均衡 [x]</p>\n</blockquote>\n<h4 id=\"解答-11\"><a class=\"anchor\" href=\"#解答-11\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：</p>\n<ol>\n<li>在这种情况下，弹性是能够在需要时提供额外的计算资源并减少不需要时计算资源以降低成本。 自动缩放是弹性的一个例子。</li>\n<li>弹性计算是快速扩展或减少计算机处理、内存和存储的能力资源来满足不断变化的需求，而无需担心峰值的容量规划和工程用法。 通常由系统监控工具控制，弹性计算匹配资源量在不中断运营的情况下分配给实际需要的资源量。 有了云弹性，公司避免为未使用的容量或闲置资源付费，并且不必担心投资购买或维护额外的资源和设备。</li>\n</ol>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9henVyZS5taWNyb3NvZnQuY29tL2VuLWdiL292ZXJ2aWV3L3doYXQtaXMtZWxhc3RpYy1jb21wdXRpbmcv\">https://azure.microsoft.com/en-gb/overview/what-is-elastic-computing/</span></p>\n</div>\n<h3 id=\"问题-12\"><a class=\"anchor\" href=\"#问题-12\">#</a> 问题 12</h3>\n<blockquote>\n<p>你计划将 Web 应用程序迁移到 Azure。Web 应用程序由外部用户访问。<br />\n你需要推荐一种云部署解决方案，以最大限度地减少用于管理 Web 应用程序的管理工作量。<br />\n你应该在建议中包含哪些内容？（B）<br />\nA. 软件即服务（SaaS）[x]<br />\n B. 平台即服务（PaaS） [√]<br />\n C. 基础即服务（IaaS） [x]<br />\n D. 数据库即服务（DaaS） [x]</p>\n</blockquote>\n<h4 id=\"解答-12\"><a class=\"anchor\" href=\"#解答-12\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：<br />\nAzure 应用服务时一种平台即服务（PaaS）产品。可让你为任何平台或设备创建 Web 和移动应用程序，并连接到云中或者本地任意位置的数据。应用服务包括以前座位 Azure 网站和 Azure 移动服务单独提供的 Web 和移动功能。</p>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvYXp1cmUvc2VjdXJpdHkvZnVuZGFtZW50YWxzL3BhYXMtYXBwbGljYXRpb25zLXVzaW5nLWFwcC1zZXJ2aWNlcw==\">https://docs.microsoft.com/en-us/azure/security/fundamentals/paas-applications-using-app-services</span></p>\n</div>\n<h3 id=\"问题-13\"><a class=\"anchor\" href=\"#问题-13\">#</a> 问题 13</h3>\n<blockquote>\n<p>Azure 虚拟机和 Azure SQL 数据库使用哪种云部署解决方案？<br />\nAzure 虚拟机（A）<br />\nA. 基础设施即服务（IaaS） [√]<br />\n B. 平台即服务（PaaS） [x]<br />\n C. 软件即服务（SaaS） [x]<br />\n Azure SQL 数据库（B）<br />\nA. 基础设施即服务（IaaS） [x]<br />\n B. 平台即服务（PaaS） [√]<br />\n C. 软件即服务（SaaS） [x]</p>\n</blockquote>\n<h4 id=\"解答-13\"><a class=\"anchor\" href=\"#解答-13\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：<br />\nAzure 虚拟机是基础结构即服务 (IaaS)。<br />\n基础设施即服务是最灵活的云服务类别。 它旨在为您提供完整的控制运行您的应用程序的硬件（IT 基础架构服务器和虚拟机 (VM)，存储、网络和操作系统）。 有了 IaaS，您无需购买硬件，而是租用它。<br />\nAzure SQL 数据库是平台即服务 (Paas)。<br />\nAzure SQL 数据库是一个完全托管的平台即服务 (PaaS) 数据库引擎，可处理大多数升级、打补丁、备份、监控等数据库管理功能，无需用户参与。 Azure SQL 数据库始终在 SQL Server 数据库的最新稳定版本上运行引擎和打补丁的操作系统具有 99.99% 的可用性。 Azure SQL 中内置的 PaaS 功能数据库使您能够专注于特定领域的数据库管理和优化活动，这对您的业务至关重要。</p>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tZ2IvbGVhcm4vbW9kdWxlcy9wcmluY2lwbGVzLWNsb3VkLWNvbXB1dGluZy81LXR5cGVzLW9mLWNsb3VkLXNlcnZpY2Vz\">https://docs.microsoft.com/en-gb/learn/modules/principles-cloud-computing/5-types-of-cloud-services</span><br />\n 链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvYXp1cmUvc3FsLWRhdGFiYXNlL3NxbC1kYXRhYmFzZS1wYWFzLWluZGV4\">https://docs.microsoft.com/en-us/azure/sql-database/sql-database-paas-index</span></p>\n</div>\n<h3 id=\"问题-14\"><a class=\"anchor\" href=\"#问题-14\">#</a> 问题 14</h3>\n<blockquote>\n<p>你有一个包含 100 台服务器的本地网络。<br />\n你需要推荐一种可为用户提供额外资源解决方案。该解决方案必须最大限度地减少资本和运营支出成本。<br />\n你应该在建议中包含哪些内容？（D）<br />\nA. 完全迁移到公有云 [x]<br />\n B. 额外的数据中心 [x]<br />\n C. 私有云 [x]<br />\n D. 混合云 [√]</p>\n</blockquote>\n<h4 id=\"解答-14\"><a class=\"anchor\" href=\"#解答-14\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：<br />\n混合云是私有云和公共云的组合。<br />\n资本支出是用于基础设施（例如新服务器）的前期支出。<br />\n使用混合云，您可以继续使用本地服务器，同时在公共云（例如 Azure）。 在 Azure 中添加新服务器可将资本支出成本降至最低，因为您不会像在本地部署新服务器那样为新服务器付费。<br />\n不正确的答案：<br />\nA：将 100 台服务器完整迁移到公有云将涉及大量运营支出（迁移所有服务器的成本）。<br />\nB：额外的数据中心将涉及大量资本支出（新基础设施的成本）。<br />\nC：私有云托管在本地服务器上，这将涉及大量资本支出（托管私有云的新基础架构的成本）。</p>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tZ2IvbGVhcm4vbW9kdWxlcy9wcmluY2lwbGVzLWNsb3VkLWNvbXB1dGluZy80LWNsb3VkLWRlcGxveW1lbnQtbW9kZWxz\">https://docs.microsoft.com/en-gb/learn/modules/principles-cloud-computing/4-cloud-deployment-models</span></p>\n</div>\n<h3 id=\"问题-15\"><a class=\"anchor\" href=\"#问题-15\">#</a> 问题 15</h3>\n<blockquote>\n<ol>\n<li>要实现混合云模型。公司必须始终从私有云迁移模型。[x]</li>\n<li>公司可以通过使用公共云来扩展起内部网络的容量。[√]</li>\n<li>在公共云模型中，只有公司的来宾用户可以访问云。[x]</li>\n</ol>\n</blockquote>\n<h4 id=\"解答-15\"><a class=\"anchor\" href=\"#解答-15\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：</p>\n<ol>\n<li>否<br />\n公司必须始终从私有云模型迁移以实施混合云是不正确的。<br />\n您可以从公共云开始，然后将其与内部部署的基础设施相结合来实施混合云。</li>\n<li>是的<br />\n公司可以通过使用公共云来扩展其内部网络的容量。这是很常见的。<br />\n当您需要更多容量而不是为新的本地基础架构付费时，您可以配置一个云环境，并使用 VPN 将您的本地网络连接到云环境。</li>\n<li>否<br />\n并非只有访客用户才能访问云资源。你可以给任何有账户的人 Azure Active Directory 访问云资源。有很多身份验证场景，但一个常见的一种是将本地 Active Directory 帐户复制到 Azure Active Directory 和提供对 Azure Active Directory 帐户的访问。另一种常用的身份验证方法是 “联合”，其中访问云资源的身份验证传递给另一个身份验证提供程序，例如本地 Active Directory。</li>\n</ol>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9henVyZS5taWNyb3NvZnQuY29tL2VuLWdiL292ZXJ2aWV3L3doYXQtaXMtaHlicmlkLWNsb3VkLWNvbXB1dGluZy8=\">https://azure.microsoft.com/en-gb/overview/what-is-hybrid-cloud-computing/</span></p>\n</div>\n<h3 id=\"问题-16\"><a class=\"anchor\" href=\"#问题-16\">#</a> 问题 16</h3>\n<blockquote>\n<p>你计划将多个服务器从本地网络迁移到 Azure。<br />\n通过本地网络为服务器使用公共云服务有什么优势？（D）<br />\nA. 公共云归公司所有，而不是私人访问。[x]<br />\n B. 公共云是一种众包解决方案，可为企业提供增强云的能力。[x]<br />\n C. 所有公共云资源都可以被每个公众成员自由访问。[x]<br />\n D. 公共云是一个共享实体，多个公司各自使用云中的一部分资源。[√]</p>\n</blockquote>\n<h4 id=\"解答-16\"><a class=\"anchor\" href=\"#解答-16\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：<br />\n公共云是一个共享实体，多个公司各自使用云中的一部分资源。 硬件资源（服务器、基础设施等）由云提供商管理。 多家公司在硬件资源上创建虚拟机和虚拟网络等资源。<br />\n不正确的答案：<br />\nA：公有云不为公众所有。 就 Microsoft Azure 而言，云由 Microsoft 拥有。<br />\nB：公共云不是众包解决方案。 就 Microsoft Azure 而言，云由 Microsoft 拥有。<br />\nC：公有云资源可以被每个公众成员自由访问是不正确的。 您为云订阅付费并为您的用户创建帐户以访问您的云资源。 在您创建用户帐户并提供适当的访问权限之前，没有人可以访问您的云资源。</p>\n</div>\n<h3 id=\"问题-17\"><a class=\"anchor\" href=\"#问题-17\">#</a> 问题 17</h3>\n<blockquote>\n<p>Azure Site Recovery 提供（A）对于虚拟机<br />\n A. 容错 [√]<br />\n B. 灾难恢复 [x]<br />\n C. 弹性 [x]<br />\n D. 高可用性 [x]</p>\n</blockquote>\n<h4 id=\"解答-17\"><a class=\"anchor\" href=\"#解答-17\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：<br />\nAzure Site Recovery 通过在终端期间保持业务应用和工作负载运行来邦族确保业务连续性。Sute Recovery 将在物理机和虚拟机（VM）上运行的工作负载从主站点复制到次要位置。</p>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvYXp1cmUvc2l0ZS1yZWNvdmVyeS9zaXRlLXJlY292ZXJ5LW92ZXJ2aWV3\">https://docs.microsoft.com/en-us/azure/site-recovery/site-recovery-overview</span></p>\n</div>\n<h3 id=\"问题-18\"><a class=\"anchor\" href=\"#问题-18\">#</a> 问题 18</h3>\n<blockquote>\n<p>在那种类型的云模型中，所有硬件资源都归宿第三方所有并在多个租户之间共享？（C）<br />\nA. 私人的 [x]<br />\n B. 杂交种 [x]<br />\n C. 上市 [√]</p>\n</blockquote>\n<h4 id=\"解答-18\"><a class=\"anchor\" href=\"#解答-18\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：<br />\nMicrosoft Azure,Amazon Web Services 和 Google Cloud 是公共云服务的三个示例。微软，亚马逊和谷歌拥有硬件。租户是使用公共云服务的客户。</p>\n</div>\n<h3 id=\"问题-19\"><a class=\"anchor\" href=\"#问题-19\">#</a> 问题 19</h3>\n<blockquote>\n<p>查询本地 Microsoft SQL 的 Azure web 应用程序服务器是（A）云<br />\n A. 混合的 [√]<br />\n B. 多供应商 [x]<br />\n C. 私人 [x]<br />\n D. 公开 [x]</p>\n</blockquote>\n<h4 id=\"解答-19\"><a class=\"anchor\" href=\"#解答-19\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：参考链接</p>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9henVyZS5taWNyb3NvZnQuY29tL2VuLWdiL292ZXJ2aWV3L3doYXQtaXMtaHlicmlkLWNsb3VkLWNvbXB1dGluZy8=\">https://azure.microsoft.com/en-gb/overview/what-is-hybrid-cloud-computing/</span></p>\n</div>\n<h3 id=\"问题-20\"><a class=\"anchor\" href=\"#问题-20\">#</a> 问题 20</h3>\n<blockquote>\n<p>你有 1000 台虚拟机托管正在数据中心的 Hyper-V 主机上。<br />\n你计划将所有虚拟机迁移到 Azure 即用即付订阅。你需要确定要用于计划的 Azure 解决方案的支出模型。你应该确定哪种支出模型？（A）<br />\nA. 操作 [√]<br />\n B. 松紧带 [x]<br />\n C. 首都 [x]<br />\n D. 可扩展的 [x]</p>\n</blockquote>\n<h4 id=\"解答-20\"><a class=\"anchor\" href=\"#解答-20\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：<br />\n当你从本地迁移到公共云时，你将勉励的主要变化之一时从资本支出（购买硬件）转向运营支出（在使用时支付费用）。此转换还需要更仔细地管理你的成本。云的好处是，你只需要在不需要时关闭或者调整他的大小，就可以从根本上积极地影响你使用的服务的成本。</p>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvYXp1cmUvYXJjaGl0ZWN0dXJlL2Nsb3VkLWFkb3B0aW9uL2FwcGVuZGl4L2F6dXJlLXNjYWZmb2xk\">https://docs.microsoft.com/en-us/azure/architecture/cloud-adoption/appendix/azure-scaffold</span></p>\n</div>\n<h3 id=\"问题-21\"><a class=\"anchor\" href=\"#问题-21\">#</a> 问题 21</h3>\n<blockquote>\n<p>将 Azure 云服务权益与正确的描述相匹配。<br />\n失败后仍然可用云服务（发生） ===&gt; [容错]<br />\n 故障后可以恢复的云服务（发生） ===&gt; [灾难恢复]<br />\n 在需要是快速之行的云服务（增加） ===&gt; [动态可扩展性]<br />\n 可以快速访问的云服务（从互联网上） ===&gt; [低延迟]</p>\n</blockquote>\n<h4 id=\"解答-21\"><a class=\"anchor\" href=\"#解答-21\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：</p>\n<ol>\n<li>容错是服务的一个组件发生腹胀后保持可用的能力。例如：运行在多台服务器上的服务可以承受其中的一台服务器的故障。</li>\n<li>灾难恢复时服务器发生付帐后的恢复。例如：在虚拟机出现付帐后从备份恢复虚拟机。</li>\n<li>动态可扩展性时在服务堵在较重时将计算资源添加到服务的能力，例如：在虚拟机规模集中，当现有虚拟机负载过重时，会添加格外的虚拟机实例。</li>\n<li>延迟时服务器响应请求的时间。例如：从 Web 服务器返回网页所需的时间，低延迟意味着地相应时间，这意味着更快的响应。</li>\n</ol>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbWFnYXppbmUvbXQ0MjI1ODIuYXNweA==\">https://msdn.microsoft.com/en-us/magazine/mt422582.aspx</span><br />\n 链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWFyY2hkaXNhc3RlcnJlY292ZXJ5LnRlY2h0YXJnZXQuY29tL2RlZmluaXRpb24vY2xvdWQtZGlzYXN0ZXItcmVjb3ZlcnktY2xvdWQtRFI=\">https://searchdisasterrecovery.techtarget.com/definition/cloud-disaster-recovery-cloud-DR</span><br />\n 链接：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zaWFzbXNwLmNvbS90aGUtYmVuZWZpdC1vZi1zY2FsYWJpbGl0eS1pbi1jbG91ZC1jb21wdXRpbmctMi8=\">http://www.siasmsp.com/the-benefit-of-scalability-in-cloud-computing-2/</span><br />\n 链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9henVyZS5taWNyb3NvZnQuY29tL2VuLWluL292ZXJ2aWV3L3doYXQtaXMtY2xvdWQtY29tcHV0aW5nLw==\">https://azure.microsoft.com/en-in/overview/what-is-cloud-computing/</span></p>\n</div>\n<h3 id=\"问题-22\"><a class=\"anchor\" href=\"#问题-22\">#</a> 问题 22</h3>\n<blockquote>\n<ol>\n<li>要实现混合云模型，公司必须又内部网络。[x]</li>\n<li>公司可以扩展其内部网络的计算资源使用混合云。 [√]</li>\n<li>在公共云模型中，只有你公司的来宾用户可以访问云中的资源。[x]</li>\n</ol>\n</blockquote>\n<h4 id=\"解答-22\"><a class=\"anchor\" href=\"#解答-22\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：</p>\n<ol>\n<li>否<br />\n公司必须失踪从内部网络迁移一实施混合云时不正确的。你可以从公共云开始，然后将其与本地基础架构想解和以实施混合云。</li>\n<li>是<br />\n企业可以通过佛念佛有云扩展其内部网络的计算资源，是很常见的。当你需要更多资源而不是为新的本地基础架构复位时，你可以配置云环境并使用 VPN 将本地网络链接到云环境。</li>\n<li>否<br />\n并非只有方可用户才能访问云资源。你可以授予拥有 Azure Active Directory 账户得任何人方云云资源得权限。有许多身份验证方案。但常见得一种时将本地 Active Directory 账户复制到 Azure Active Directory 并提供对 Azure Active Directory 账户访问。另一种常用得身份验证方法是 &quot;联合&quot;, 其中访问云资源得身份验证传递给另一种身份验证提供程序，例如本地 Active Directory。</li>\n</ol>\n</div>\n<div class=\"note primary\">\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9henVyZS5taWNyb3NvZnQuY29tL2VuLWdiL292ZXJ2aWV3L3doYXQtaXMtaHlicmlkLWNsb3VkLWNvbXB1dGluZy8=\">https://azure.microsoft.com/en-gb/overview/what-is-hybrid-cloud-computing/</span></p>\n</div>\n<h3 id=\"问题-23\"><a class=\"anchor\" href=\"#问题-23\">#</a> 问题 23</h3>\n<blockquote>\n<ol>\n<li>平台即服务（PaaS）解决方案提供了，完全的控制托管应用程序的操作系统。[x]</li>\n<li>平台即服务（PaaS）解决方案提供了通过更改定价层将内存转换为应用程序。[x]</li>\n<li>平台即服务（PaaS）解决方案可以自动存放实例数。[√]</li>\n</ol>\n</blockquote>\n<h4 id=\"解答-23\"><a class=\"anchor\" href=\"#解答-23\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：</p>\n</div>\n<div class=\"note primary\">\n<p>链接：</p>\n</div>\n<h3 id=\"问题-24\"><a class=\"anchor\" href=\"#问题-24\">#</a> 问题 24</h3>\n<blockquote>\n<p>你的公司有一个包含多个服务器的内部网络。该公司计划减少一下网络管理员的管理职责：<br />\n-- 备份应用数据<br />\n -- 替换失败的服务器硬件<br />\n -- 管理物理服务器的安全性<br />\n -- 更新服务器操作系统<br />\n -- 管理对共享文档的权限<br />\n该公司计划将几台服务器迁移到 Azure 虚拟机上，你需要确定在计划的迁移之后哪些管理职责将被取消，你应该确定哪两个责任？(AC) 每个正确答案提供了一个完整的解决方案。<br />\nA. 替换失败的服务器硬件 [√]<br />\n B. 备份应用程序数据 [x]<br />\n C. 管理物理服务器安全性 [√]<br />\n D. 更新服务器操作系统 [x]<br />\n E. 管理对共享文档的权限 [x]</p>\n</blockquote>\n<h4 id=\"解答-24\"><a class=\"anchor\" href=\"#解答-24\">#</a> 解答</h4>\n<div class=\"note info\">\n<p>原因：<br />\nAzure 虚拟机运行在 Hyper-V 物理服务器上。物理服务器由微软拥有和管理，座位一个 azure 客户，你没有访问物理服务器的权限。微软负责更换失败的服务器硬件和物理服务器的安全，所以你不需要这么做。</p>\n</div>\n<div class=\"note warning\">\n<p>错误答案：<br />\nB.Microsoft 无法控制你在虚拟机上运行的应用程序。因此，确保应用程序数据备份是你的责任。<br />\nD. 微软部管理你在虚拟机上运行的操作系统。因此，确保操作系统更新是你的责任。<br />\nE.Microsoft 无法控制你在虚拟机上托管的共享文件夹。因此，确保文件夹权限被正确配置是你的责任。</p>\n</div>\n<div class=\"note primary\">\n<p>链接：</p>\n</div>\n",
            "tags": [
                "Azure",
                "Azure",
                "微软"
            ]
        }
    ]
}